"""
.NET documentation generation module.

Parses .NET XML documentation files generated by the compiler and .csproj/.sln files
to extract API documentation for .NET projects.

XML documentation is generated when <GenerateDocumentationFile>true</GenerateDocumentationFile>
is set in the project file. The compiler outputs an XML file alongside the DLL.
"""

from __future__ import annotations

import re
import shutil
import subprocess
import xml.etree.ElementTree as ET
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any


@dataclass
class DotNetParameter:
    """Represents a method/constructor parameter."""

    name: str
    type: str | None = None
    description: str | None = None

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary, omitting None values."""
        result: dict[str, Any] = {"name": self.name}
        if self.type:
            result["type"] = self.type
        if self.description:
            result["description"] = self.description
        return result


@dataclass
class DotNetMethod:
    """Represents a method or constructor."""

    name: str
    signature: str | None = None
    summary: str | None = None
    parameters: list[DotNetParameter] = field(default_factory=list)
    return_type: str | None = None
    return_description: str | None = None
    is_static: bool = False
    is_async: bool = False
    visibility: str = "public"

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary, omitting None values."""
        result: dict[str, Any] = {"name": self.name}
        if self.signature:
            result["signature"] = self.signature
        if self.summary:
            result["summary"] = self.summary
        if self.parameters:
            result["parameters"] = [p.to_dict() for p in self.parameters]
        if self.return_type:
            result["returns"] = {"type": self.return_type}
            if self.return_description:
                result["returns"]["description"] = self.return_description
        if self.is_static:
            result["static"] = True
        if self.is_async:
            result["async"] = True
        if self.visibility != "public":
            result["visibility"] = self.visibility
        return result


@dataclass
class DotNetProperty:
    """Represents a property."""

    name: str
    type: str | None = None
    summary: str | None = None
    has_getter: bool = True
    has_setter: bool = True
    is_static: bool = False

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary, omitting None values."""
        result: dict[str, Any] = {"name": self.name}
        if self.type:
            result["type"] = self.type
        if self.summary:
            result["summary"] = self.summary
        if self.is_static:
            result["static"] = True
        if not self.has_getter:
            result["getter"] = False
        if not self.has_setter:
            result["setter"] = False
        return result


@dataclass
class DotNetField:
    """Represents a field."""

    name: str
    type: str | None = None
    summary: str | None = None
    is_static: bool = False
    is_readonly: bool = False
    is_const: bool = False

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary, omitting None values."""
        result: dict[str, Any] = {"name": self.name}
        if self.type:
            result["type"] = self.type
        if self.summary:
            result["summary"] = self.summary
        if self.is_static:
            result["static"] = True
        if self.is_readonly:
            result["readonly"] = True
        if self.is_const:
            result["const"] = True
        return result


@dataclass
class DotNetEvent:
    """Represents an event."""

    name: str
    type: str | None = None
    summary: str | None = None

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary, omitting None values."""
        result: dict[str, Any] = {"name": self.name}
        if self.type:
            result["type"] = self.type
        if self.summary:
            result["summary"] = self.summary
        return result


@dataclass
class DotNetType:
    """Represents a class, struct, interface, enum, or delegate."""

    name: str
    kind: str = "class"  # class, struct, interface, enum, delegate, record
    namespace: str | None = None
    summary: str | None = None
    bases: list[str] = field(default_factory=list)
    methods: list[DotNetMethod] = field(default_factory=list)
    properties: list[DotNetProperty] = field(default_factory=list)
    fields: list[DotNetField] = field(default_factory=list)
    events: list[DotNetEvent] = field(default_factory=list)
    nested_types: list[DotNetType] = field(default_factory=list)
    is_static: bool = False
    is_abstract: bool = False
    is_sealed: bool = False

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary, omitting None values."""
        result: dict[str, Any] = {"name": self.name, "kind": self.kind}
        if self.namespace:
            result["namespace"] = self.namespace
        if self.summary:
            result["summary"] = self.summary
        if self.bases:
            result["bases"] = self.bases
        if self.methods:
            result["methods"] = [m.to_dict() for m in self.methods]
        if self.properties:
            result["properties"] = [p.to_dict() for p in self.properties]
        if self.fields:
            result["fields"] = [f.to_dict() for f in self.fields]
        if self.events:
            result["events"] = [e.to_dict() for e in self.events]
        if self.nested_types:
            result["nested_types"] = [t.to_dict() for t in self.nested_types]
        if self.is_static:
            result["static"] = True
        if self.is_abstract:
            result["abstract"] = True
        if self.is_sealed:
            result["sealed"] = True
        return result


@dataclass
class DotNetNamespace:
    """Represents a namespace containing types."""

    name: str
    types: list[DotNetType] = field(default_factory=list)
    child_namespaces: list[str] = field(default_factory=list)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        result: dict[str, Any] = {"name": self.name}
        if self.types:
            result["types"] = [t.to_dict() for t in self.types]
        if self.child_namespaces:
            result["child_namespaces"] = self.child_namespaces
        return result


@dataclass
class DotNetAssembly:
    """Represents a .NET assembly with its documentation."""

    name: str
    version: str | None = None
    namespaces: list[DotNetNamespace] = field(default_factory=list)
    target_framework: str | None = None

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        result: dict[str, Any] = {"name": self.name}
        if self.version:
            result["version"] = self.version
        if self.target_framework:
            result["target_framework"] = self.target_framework
        if self.namespaces:
            result["namespaces"] = [n.to_dict() for n in self.namespaces]
        return result


def check_dotnet_available() -> bool:
    """Check if .NET SDK is available."""
    return shutil.which("dotnet") is not None


def get_dotnet_version() -> str | None:
    """Get the installed .NET SDK version."""
    if not check_dotnet_available():
        return None
    try:
        result = subprocess.run(
            ["dotnet", "--version"],
            capture_output=True,
            text=True,
            timeout=10,
        )
        if result.returncode == 0:
            return result.stdout.strip()
    except (subprocess.TimeoutExpired, OSError):
        pass
    return None


def _parse_member_name(member_id: str) -> tuple[str, str, str | None]:
    """
    Parse a member ID from XML documentation.

    Member IDs follow the format: <prefix>:<full_name>
    Prefixes:
        T: Type (class, struct, interface, enum, delegate)
        M: Method (including constructors)
        P: Property
        F: Field
        E: Event
        N: Namespace

    Returns: (kind, full_name, signature_part)
    """
    if ":" not in member_id:
        return ("unknown", member_id, None)

    prefix, rest = member_id.split(":", 1)

    kind_map = {
        "T": "type",
        "M": "method",
        "P": "property",
        "F": "field",
        "E": "event",
        "N": "namespace",
    }
    kind = kind_map.get(prefix, "unknown")

    # Extract signature part for methods
    signature = None
    if "(" in rest:
        name_part, sig_part = rest.split("(", 1)
        signature = "(" + sig_part
        rest = name_part

    return (kind, rest, signature)


def _extract_text(element: ET.Element | None) -> str | None:
    """Extract text content from an XML element, handling nested elements."""
    if element is None:
        return None

    # Get all text including from child elements
    text_parts = []

    if element.text:
        text_parts.append(element.text.strip())

    for child in element:
        # Handle <see cref="..."/> and <paramref name="..."/> elements
        if child.tag == "see":
            cref = child.get("cref", "")
            # Extract just the type/member name from cref
            if ":" in cref:
                cref = cref.split(":", 1)[1]
            if "." in cref:
                cref = cref.split(".")[-1]
            text_parts.append(cref)
        elif child.tag == "paramref":
            text_parts.append(child.get("name", ""))
        elif child.tag == "c":
            # Inline code
            if child.text:
                text_parts.append(f"`{child.text}`")
        elif child.text:
            text_parts.append(child.text.strip())

        if child.tail:
            text_parts.append(child.tail.strip())

    text = " ".join(filter(None, text_parts))
    # Normalize whitespace
    text = re.sub(r"\s+", " ", text).strip()
    return text if text else None


def _parse_type_name(full_name: str) -> tuple[str | None, str]:
    """Parse a full type name into namespace and type name."""
    if "." not in full_name:
        return (None, full_name)

    parts = full_name.rsplit(".", 1)
    return (parts[0], parts[1])


def _parse_method_params(signature: str | None) -> list[str]:
    """Parse method signature to extract parameter types."""
    if not signature or signature == "()":
        return []

    # Remove parentheses
    sig = signature.strip("()")
    if not sig:
        return []

    # Split by comma, handling generic types
    params = []
    depth = 0
    current = []

    for char in sig:
        if char in "<{[":
            depth += 1
            current.append(char)
        elif char in ">}]":
            depth -= 1
            current.append(char)
        elif char == "," and depth == 0:
            params.append("".join(current).strip())
            current = []
        else:
            current.append(char)

    if current:
        params.append("".join(current).strip())

    return params


def parse_xml_docs(xml_path: str | Path) -> DotNetAssembly:
    """
    Parse a .NET XML documentation file.

    Args:
        xml_path: Path to the XML documentation file

    Returns:
        DotNetAssembly with parsed documentation
    """
    xml_path = Path(xml_path)

    if not xml_path.exists():
        raise FileNotFoundError(f"XML documentation file not found: {xml_path}")

    tree = ET.parse(xml_path)
    root = tree.getroot()

    # Get assembly name
    assembly_elem = root.find("assembly/name")
    assembly_name = assembly_elem.text if assembly_elem is not None else xml_path.stem

    # Parse all members
    types_by_name: dict[str, DotNetType] = {}
    namespaces: set[str] = set()

    members = root.find("members")
    if members is None:
        return DotNetAssembly(name=assembly_name)

    # First pass: collect all types
    for member in members.findall("member"):
        member_id = member.get("name", "")
        kind, full_name, signature = _parse_member_name(member_id)

        if kind == "type":
            namespace, type_name = _parse_type_name(full_name)
            if namespace:
                namespaces.add(namespace)

            summary = _extract_text(member.find("summary"))

            # Determine type kind from name conventions
            type_kind = "class"
            if (
                type_name.startswith("I")
                and len(type_name) > 1
                and type_name[1].isupper()
            ):
                type_kind = "interface"

            dotnet_type = DotNetType(
                name=type_name,
                kind=type_kind,
                namespace=namespace,
                summary=summary,
            )
            types_by_name[full_name] = dotnet_type

    # Second pass: collect members for each type
    for member in members.findall("member"):
        member_id = member.get("name", "")
        kind, full_name, signature = _parse_member_name(member_id)

        if kind in ("method", "property", "field", "event"):
            # Find the owning type
            type_name = full_name.rsplit(".", 1)[0] if "." in full_name else None
            member_name = (
                full_name.rsplit(".", 1)[-1] if "." in full_name else full_name
            )

            # Handle generic type parameters in type name
            if "`" in str(type_name):
                type_name = type_name.split("`")[0]

            if type_name and type_name in types_by_name:
                dotnet_type = types_by_name[type_name]
                summary = _extract_text(member.find("summary"))

                if kind == "method":
                    # Parse parameters
                    params = []
                    param_types = _parse_method_params(signature)

                    for param_elem in member.findall("param"):
                        param_name = param_elem.get("name", "")
                        param_desc = _extract_text(param_elem)
                        param_type = param_types.pop(0) if param_types else None
                        params.append(
                            DotNetParameter(
                                name=param_name,
                                type=param_type,
                                description=param_desc,
                            )
                        )

                    # Parse returns
                    returns_elem = member.find("returns")
                    return_desc = _extract_text(returns_elem)

                    method = DotNetMethod(
                        name=member_name,
                        signature=signature,
                        summary=summary,
                        parameters=params,
                        return_description=return_desc,
                    )
                    dotnet_type.methods.append(method)

                elif kind == "property":
                    prop = DotNetProperty(
                        name=member_name,
                        summary=summary,
                    )
                    dotnet_type.properties.append(prop)

                elif kind == "field":
                    fld = DotNetField(
                        name=member_name,
                        summary=summary,
                    )
                    dotnet_type.fields.append(fld)

                elif kind == "event":
                    evt = DotNetEvent(
                        name=member_name,
                        summary=summary,
                    )
                    dotnet_type.events.append(evt)

    # Organize types by namespace
    namespace_map: dict[str, DotNetNamespace] = {}

    for full_name, dotnet_type in types_by_name.items():
        ns_name = dotnet_type.namespace or "(global)"

        if ns_name not in namespace_map:
            namespace_map[ns_name] = DotNetNamespace(name=ns_name)

        namespace_map[ns_name].types.append(dotnet_type)

    return DotNetAssembly(
        name=assembly_name,
        namespaces=list(namespace_map.values()),
    )


def detect_dotnet_project(path: str | Path | None = None) -> dict[str, Any]:
    """
    Detect .NET project configuration.

    Args:
        path: Directory to search (defaults to current directory)

    Returns:
        Dictionary with detection results
    """
    if path is None:
        path = Path.cwd()
    else:
        path = Path(path)

    result: dict[str, Any] = {
        "detected": False,
        "name": None,
        "config_file": None,
        "projects": [],
        "target_frameworks": [],
        "xml_docs": [],
    }

    # Look for solution file first
    sln_files = list(path.glob("*.sln"))
    if sln_files:
        result["detected"] = True
        result["config_file"] = sln_files[0].name
        result["name"] = sln_files[0].stem

    # Look for project files
    csproj_files = list(path.glob("**/*.csproj"))
    fsproj_files = list(path.glob("**/*.fsproj"))
    vbproj_files = list(path.glob("**/*.vbproj"))

    proj_files = csproj_files + fsproj_files + vbproj_files

    if proj_files:
        result["detected"] = True
        if not result["config_file"]:
            result["config_file"] = proj_files[0].name
            result["name"] = proj_files[0].stem

        for proj_file in proj_files:
            proj_info: dict[str, Any] = {
                "name": proj_file.stem,
                "path": str(proj_file.relative_to(path)),
                "type": proj_file.suffix[1:],  # csproj, fsproj, vbproj
            }

            # Parse project file for target framework
            try:
                tree = ET.parse(proj_file)
                root = tree.getroot()

                # Handle both old and new csproj formats
                tf = root.find(".//TargetFramework")
                if tf is not None and tf.text:
                    proj_info["target_framework"] = tf.text
                    if tf.text not in result["target_frameworks"]:
                        result["target_frameworks"].append(tf.text)

                tfs = root.find(".//TargetFrameworks")
                if tfs is not None and tfs.text:
                    for fw in tfs.text.split(";"):
                        fw = fw.strip()
                        if fw and fw not in result["target_frameworks"]:
                            result["target_frameworks"].append(fw)
                        if "target_framework" not in proj_info:
                            proj_info["target_framework"] = fw

                # Check if XML docs are enabled
                gen_doc = root.find(".//GenerateDocumentationFile")
                if gen_doc is not None and gen_doc.text:
                    proj_info["generates_docs"] = gen_doc.text.lower() == "true"

            except ET.ParseError:
                pass

            result["projects"].append(proj_info)

    # Look for existing XML documentation files
    for xml_file in path.glob("**/*.xml"):
        # Check if it looks like a documentation file
        try:
            tree = ET.parse(xml_file)
            root = tree.getroot()
            if root.find("assembly") is not None and root.find("members") is not None:
                result["xml_docs"].append(str(xml_file.relative_to(path)))
        except (ET.ParseError, OSError):
            pass

    return result


def build_dotnet_docs(
    path: str | Path | None = None,
    configuration: str = "Debug",
) -> dict[str, Any]:
    """
    Build a .NET project to generate XML documentation.

    Args:
        path: Project directory
        configuration: Build configuration (Debug/Release)

    Returns:
        Dictionary with build results
    """
    if not check_dotnet_available():
        return {"success": False, "error": ".NET SDK not available"}

    if path is None:
        path = Path.cwd()
    else:
        path = Path(path)

    result: dict[str, Any] = {
        "success": False,
        "xml_files": [],
        "errors": [],
    }

    try:
        # Build with documentation
        build_result = subprocess.run(
            [
                "dotnet",
                "build",
                "-c",
                configuration,
                "-p:GenerateDocumentationFile=true",
            ],
            cwd=path,
            capture_output=True,
            text=True,
            timeout=300,
        )

        if build_result.returncode != 0:
            result["errors"].append(build_result.stderr or build_result.stdout)
            return result

        result["success"] = True

        # Find generated XML files
        for xml_file in path.glob(f"**/bin/{configuration}/**/*.xml"):
            # Verify it's a documentation file
            try:
                tree = ET.parse(xml_file)
                root = tree.getroot()
                if root.find("assembly") is not None:
                    result["xml_files"].append(str(xml_file.relative_to(path)))
            except (ET.ParseError, OSError):
                pass

    except subprocess.TimeoutExpired:
        result["errors"].append("Build timed out")
    except OSError as e:
        result["errors"].append(str(e))

    return result


def generate_dotnet_summary(
    assembly: DotNetAssembly,
    mode: str = "standard",
) -> dict[str, Any]:
    """
    Generate a token-efficient summary of .NET documentation.

    Args:
        assembly: Parsed assembly documentation
        mode: Summary mode (minimal, standard, detailed)

    Returns:
        Dictionary with summary
    """
    result: dict[str, Any] = {
        "assembly": assembly.name,
        "mode": mode,
        "namespaces": {},
    }

    if assembly.version:
        result["version"] = assembly.version
    if assembly.target_framework:
        result["target_framework"] = assembly.target_framework

    for namespace in assembly.namespaces:
        ns_summary: dict[str, Any] = {}

        if mode == "minimal":
            # Just type names
            ns_summary["types"] = [t.name for t in namespace.types]
        elif mode == "standard":
            # Types with kind and first-line summary
            ns_summary["types"] = []
            for t in namespace.types:
                type_info: dict[str, Any] = {"name": t.name, "kind": t.kind}
                if t.summary:
                    # First sentence only
                    first_line = t.summary.split(".")[0]
                    if len(first_line) < len(t.summary):
                        first_line += "."
                    type_info["summary"] = first_line
                ns_summary["types"].append(type_info)
        else:  # detailed
            # Full type information
            ns_summary["types"] = [t.to_dict() for t in namespace.types]

        result["namespaces"][namespace.name] = ns_summary

    return result


def generate_dotnet_docs_json(
    xml_path: str | Path,
    mode: str = "standard",
    indent: int | None = None,
) -> str:
    """
    Generate JSON documentation from an XML docs file.

    Args:
        xml_path: Path to XML documentation file
        mode: Summary mode (minimal, standard, detailed, full)
        indent: JSON indentation

    Returns:
        JSON string
    """
    import json

    assembly = parse_xml_docs(xml_path)

    if mode == "full":
        data = assembly.to_dict()
    else:
        data = generate_dotnet_summary(assembly, mode)

    return json.dumps(data, indent=indent)


def find_xml_docs(path: str | Path | None = None) -> list[Path]:
    """
    Find XML documentation files in a .NET project.

    Args:
        path: Project directory

    Returns:
        List of paths to XML documentation files
    """
    if path is None:
        path = Path.cwd()
    else:
        path = Path(path)

    xml_docs = []

    for xml_file in path.glob("**/*.xml"):
        # Skip common non-doc XML files
        if xml_file.name in ("app.config", "packages.config", "nuget.config"):
            continue
        if ".nuget" in str(xml_file) or "packages" in str(xml_file):
            continue

        try:
            tree = ET.parse(xml_file)
            root = tree.getroot()
            if root.find("assembly") is not None and root.find("members") is not None:
                xml_docs.append(xml_file)
        except (ET.ParseError, OSError):
            pass

    return xml_docs


def generate_markdown(assembly: DotNetAssembly) -> str:
    """
    Generate Markdown documentation for an assembly.

    Args:
        assembly: Parsed assembly documentation

    Returns:
        Markdown string
    """
    lines = [f"# {assembly.name} API Reference\n"]

    if assembly.version:
        lines.append(f"Version: {assembly.version}\n")
    if assembly.target_framework:
        lines.append(f"Target Framework: {assembly.target_framework}\n")

    for namespace in assembly.namespaces:
        lines.append(f"\n## Namespace: {namespace.name}\n")

        for dotnet_type in namespace.types:
            lines.append(f"\n### {dotnet_type.kind.title()}: {dotnet_type.name}\n")

            if dotnet_type.summary:
                lines.append(f"{dotnet_type.summary}\n")

            if dotnet_type.bases:
                lines.append(f"\n**Inherits:** {', '.join(dotnet_type.bases)}\n")

            if dotnet_type.properties:
                lines.append("\n**Properties:**\n")
                for prop in dotnet_type.properties:
                    prop_line = f"- `{prop.name}`"
                    if prop.type:
                        prop_line += f": {prop.type}"
                    if prop.summary:
                        prop_line += f" - {prop.summary}"
                    lines.append(prop_line + "\n")

            if dotnet_type.methods:
                lines.append("\n**Methods:**\n")
                for method in dotnet_type.methods:
                    sig = method.signature or "()"
                    method_line = f"- `{method.name}{sig}`"
                    if method.summary:
                        method_line += f" - {method.summary}"
                    lines.append(method_line + "\n")

            if dotnet_type.fields:
                lines.append("\n**Fields:**\n")
                for fld in dotnet_type.fields:
                    fld_line = f"- `{fld.name}`"
                    if fld.type:
                        fld_line += f": {fld.type}"
                    if fld.summary:
                        fld_line += f" - {fld.summary}"
                    lines.append(fld_line + "\n")

            if dotnet_type.events:
                lines.append("\n**Events:**\n")
                for evt in dotnet_type.events:
                    evt_line = f"- `{evt.name}`"
                    if evt.summary:
                        evt_line += f" - {evt.summary}"
                    lines.append(evt_line + "\n")

    return "".join(lines)
