---
id: 1
created: '2026-01-03T05:35:57.660521Z'
tags:
- idea
- explore
---
# Daemon-Based Queue Architecture for Claude Code

## Concept
Use IdlerGear daemon as a command queue and orchestration layer between CLI and Claude Code sessions.

## Flow
```
User runs CLI command → Daemon queues prompt → Claude Code session picks up → Executes → Returns result to daemon → CLI polls for result
```

## Key Use Cases
1. **Queue long-running tasks** - Start tasks from CLI, Claude picks them up
2. **Background work** - Queue analysis/refactoring while working on something else
3. **Multi-session coordination** - Share work across multiple Claude sessions
4. **Persistent task queue** - Tasks survive Claude Code restarts

## Architecture

### Daemon Components
- **Prompt Queue**: FIFO queue of pending prompts
- **Result Store**: Completed task results
- **Session Registry**: Track active Claude Code sessions
- **Long-running Task Manager**: Monitor background operations

### CLI Interface
```bash
# Queue a prompt
idlergear queue add "analyze the codebase and suggest improvements"

# Check queue status
idlergear queue list

# Get result
idlergear queue result <id>

# Start daemon with auto-pickup
idlergear daemon start --auto-queue
```

### Hook Integration
**SessionStart**: Check daemon for queued prompts, inject into session
**PostToolUse**: Send results back to daemon
**Stop**: Check if more queued work before allowing stop

## Questions to Explore
1. How does Claude "pick up" a queued prompt? Via SessionStart hook injection?
2. What if multiple Claude sessions are active? (priority/assignment system?)
3. How to handle failures? (retry, dead letter queue?)
4. Should daemon auto-start Claude Code if idle and work queued?
5. Inter-session communication protocol?
