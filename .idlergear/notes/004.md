---
id: 4
created: '2026-01-07T01:35:24.496339Z'
tags:
- analysis
- goose
- architecture
- idea
---
# Deep Analysis: IdlerGear + Goose Integration Strategy

## Context
Goose is Block's AI coding assistant with both CLI and GUI interfaces. How can IdlerGear be enhanced to fulfill its vision when working with Goose?

## Vision Alignment
IdlerGear's mission: "Structured project management for AI-assisted development that works across all AI assistants"

Key insight: "A virtuous cycle where AI queries IdlerGear for context, stores discoveries via API, and knowledge accumulates across sessions"

## Goose-Specific Challenges

### 1. **Dual Interface Problem (CLI + GUI)**
- CLI Goose: Terminal-based, MCP tools work well
- GUI Goose: Visual interface, needs different UX patterns
- **Gap**: IdlerGear is optimized for CLI/MCP but GUI needs visual feedback

### 2. **Session Continuity**
- Goose (like Claude Code) is stateless between sessions
- **Current**: User must manually run `idlergear context`
- **Needed**: Automatic context injection on session start

### 3. **Knowledge Write Adoption**
- Goose can READ via MCP tools but doesn't think to WRITE discoveries
- **Gap**: No Goose-specific hooks/triggers for proactive knowledge capture

### 4. **Multi-Modal Context**
- Goose can handle images, code, terminal output
- **Gap**: IdlerGear doesn't capture visual/multi-modal discoveries

## Architectural Improvements for Goose

### A. **Goose-Aware Session Management**

**Problem**: Goose sessions don't automatically load project context

**Solution**: Goose-specific initialization pattern
```bash
# In .goosehints or Goose config
on_session_start: "idlergear context --format goose"
```

**New Feature**: `--format goose` flag
- Returns context optimized for Goose's conversation model
- Includes visual markers for GUI rendering
- Prioritizes high-signal information (top 3 tasks, not all tasks)

### B. **Conversational Knowledge Capture**

**Problem**: Goose won't proactively call `idlergear note create`

**Solution 1: Prompt-Based Triggers**
Add to `.goosehints`:
```
When you discover something important, ALWAYS run:
idlergear note create "your discovery"

When you find a bug, ALWAYS run:
idlergear task create "bug description" --label bug

When you make an architectural decision, ALWAYS run:
idlergear reference add "Decision Title" --body "rationale"
```

**Solution 2: Session-End Prompts** (NEW FEATURE)
```bash
idlergear session end
# Prompts AI: "What did we discover this session?"
# Captures response as note automatically
```

### C. **GUI-Optimized Outputs**

**Problem**: IdlerGear output is text-only, not GUI-friendly

**New Feature**: Rich output formats
```bash
idlergear status --format json        # Existing
idlergear status --format markdown    # GUI rendering
idlergear status --format html        # Visual dashboard
idlergear status --format goose-card  # Goose GUI card format
```

**GUI Card Format**: 
- Visual badges (ðŸ”´ 3 high-priority tasks)
- Collapsible sections
- Clickable task IDs
- Progress indicators

### D. **Async/Background Knowledge Sync**

**Problem**: Goose sessions block on slow operations

**Solution**: Daemon-backed async operations
```bash
# Goose calls this (fast)
idlergear task create "big task" --async

# Daemon handles GitHub sync in background
# Goose gets immediate confirmation, sync happens later
```

**Architecture**:
```
Goose MCP call â†’ IdlerGear CLI â†’ Daemon queue â†’ GitHub API
                       â†“
                  Immediate response
```

### E. **Multi-Agent Coordination**

**Problem**: User might have both Goose + Claude Code + Aider open

**Solution**: Daemon-based coordination (already planned in #66)
- Multiple AI sessions share same knowledge base
- Real-time updates when Task X is completed in Claude, Goose sees it
- Lock-free reads, coordinated writes

**Use Case**:
```
Claude Code (terminal): Working on backend
Goose GUI: Working on frontend
Aider: Running tests

All three see same task list, notes, run status
```

### F. **Goose-Specific MCP Tool Enhancements**

**New Tools for Better UX**:

1. **`idlergear_context_summary()`** 
   - Lightweight version of `idlergear_context()`
   - Returns only changed items since last session
   - "2 new tasks, 1 completed, 3 new notes"

2. **`idlergear_session_diff()`**
   - What changed since I was last here?
   - Git-style diff of knowledge state

3. **`idlergear_suggest()`**
   - AI-facing tool that suggests what to capture
   - "You just fixed a bug - create a task?"
   - "You explained how X works - add reference?"

4. **`idlergear_batch_create()`**
   - Create multiple items in one call
   - Reduces MCP round-trips
   - Better for end-of-session knowledge dumps

### G. **Visual Knowledge Browser** (Goose GUI specific)

**New Feature**: GUI companion tool
```bash
idlergear serve --gui
# Launches local web UI on localhost:8080
```

**Features**:
- Kanban board for tasks
- Graph view of note â†’ task â†’ plan relationships
- Timeline of runs/sessions
- Search across all knowledge types

**Goose Integration**:
- Goose GUI can embed iframe to IdlerGear UI
- Or: Deep links from Goose chat to specific tasks/notes

### H. **Smart Context Windowing**

**Problem**: Full context might be too large for Goose's context window

**Solution**: Intelligent context prioritization
```bash
idlergear context --mode smart
```

**Algorithm**:
1. Always include: vision, current plan
2. Recent items (last 7 days): tasks, notes
3. Active runs
4. References: only if mentioned in recent tasks/notes
5. Omit: closed tasks older than 30 days

**Config**:
```toml
[context]
mode = "smart"  # or "full", "minimal"
max_tokens = 2000
prioritize = ["vision", "tasks", "notes"]
```

### I. **Goose Template System**

**New Feature**: `.goosehints` generator
```bash
idlergear install --assistant goose

# Creates optimized .goosehints with:
# - Session start commands
# - Knowledge capture reminders
# - MCP tool usage patterns
# - Goose-specific best practices
```

**Template Contents**:
- Mandatory session start: `idlergear context --mode smart`
- Pattern matching for discoveries
- End-of-session knowledge review prompt

### J. **Bidirectional Hooks**

**Goose â†’ IdlerGear**: (via MCP tools)
- Already works

**IdlerGear â†’ Goose**: (NEW)
```bash
# IdlerGear can trigger Goose actions
idlergear watch --on-task-created "goose analyze-task {task_id}"

# When high-priority task created, Goose auto-analyzes it
```

**Architecture**: Event bus
```
IdlerGear daemon â†’ Event â†’ Goose listener â†’ MCP callback
```

## Implementation Priorities

### Phase 1: Essential (Week 1)
1. âœ… Session context command already exists
2. **NEW**: `--format goose` flag for optimized output
3. **NEW**: `.goosehints` template generator
4. **NEW**: Session end capture: `idlergear session end`

### Phase 2: Enhanced UX (Week 2)
5. **NEW**: GUI-friendly output formats (markdown, html)
6. **NEW**: Smart context windowing (`--mode smart`)
7. **NEW**: Lightweight summary tools

### Phase 3: Advanced (Week 3-4)
8. **NEW**: Async/daemon-backed operations
9. **NEW**: Multi-agent coordination
10. **NEW**: Visual knowledge browser (`idlergear serve --gui`)

### Phase 4: Future
11. **NEW**: Bidirectional hooks and event bus
12. **NEW**: Multi-modal knowledge capture (images, diagrams)

## Key Differentiators for Goose

### What Makes Goose Different from Claude Code?
1. **GUI interface** - needs visual output formats
2. **Block ecosystem** - potential integration with Square/CashApp tooling
3. **Different prompt patterns** - may need Goose-specific adoption strategies

### IdlerGear Adaptations:
- Visual output formats (not just text)
- Goose-optimized context (different from Claude's needs)
- Potential Block-specific backends (Square's internal tools)

## Success Metrics

**For Goose CLI**:
- Same adoption as Claude Code (MCP tools work identically)

**For Goose GUI**:
- Context loaded automatically in 90%+ of sessions
- Knowledge created in 70%+ of sessions (vs 20% current)
- Visual knowledge browser used regularly

## Open Questions

1. Does Goose GUI support embedded web views for `idlergear serve --gui`?
2. Can Goose trigger commands on session start/end?
3. What's Goose's context window size? (affects smart windowing)
4. Does Goose have hooks like Claude Code? (SessionStart, etc.)
5. Can Goose handle async MCP tool responses?

## Next Steps

1. Research Goose's architecture and extension points
2. Create `.goosehints` template
3. Implement `--format goose` output
4. Test MCP tools with Goose CLI
5. Prototype GUI output formats
6. Build `idlergear serve --gui` MVP
