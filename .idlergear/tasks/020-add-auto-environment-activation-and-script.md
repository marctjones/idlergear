---
id: 20
title: Add auto-environment activation and script templates for long-running processes
state: closed
created: '2026-01-03T05:52:15.494557Z'
labels:
- enhancement
- 'effort: medium'
- 'component: run'
- core-v1
priority: high
---
## Summary

Enhance `idlergear run` to automatically activate development environments (venv, conda, nvm) and provide script templates for long-running processes that register with the daemon for efficient monitoring.

## Problem

When running long processes (tests, builds, training):
1. Need to **manually activate dev environments** each time
2. Claude Code doesn't know **when to use separate terminal** vs direct execution
3. No **standardized pattern** for registering processes with daemon
4. **Inefficient monitoring** - requires polling logs instead of event-based updates

## Proposed Solution

### 1. Auto-Environment Detection and Activation

```bash
# New flag: --auto-env
idlergear run start "pytest tests/" --name tests --auto-env

# Automatically detects and activates:
# - Python: venv/bin/activate
# - Node.js: nvm use
# - Conda: conda activate
# - Ruby: rbenv local
```

**Implementation:**
```python
def detect_environment():
    """Detect development environment type."""
    if Path("venv/bin/activate").exists():
        return ("python", "source venv/bin/activate")
    elif Path(".venv/bin/activate").exists():
        return ("python", "source .venv/bin/activate")
    elif Path(".nvmrc").exists():
        return ("node", "nvm use")
    elif Path("environment.yml").exists():
        env_name = parse_conda_env()
        return ("conda", f"conda activate {env_name}")
    elif Path(".ruby-version").exists():
        return ("ruby", "rbenv local")
    return None

def run_with_env(command: str, auto_env: bool = True):
    """Run command with environment activated."""
    if auto_env:
        env_type, activate_cmd = detect_environment()
        if activate_cmd:
            command = f"{activate_cmd} && {command}"
    
    subprocess.run(command, shell=True)
```

### 2. Script Template System

Provide templates in `src/idlergear/templates/run_script.sh`:

```bash
#!/bin/bash
# Template for long-running scripts
# Generated by: idlergear run create-script <name>

set -euo pipefail

SCRIPT_NAME="{{name}}"
LOG_DIR=".idlergear/logs"
mkdir -p "$LOG_DIR"

# Auto-activate environment
{{#if env_activate}}
{{{env_activate}}}
{{/if}}

# Register with daemon
idlergear run start \
    --name "$SCRIPT_NAME" \
    --command "$0 $*" \
    --log "$LOG_DIR/${SCRIPT_NAME}.log" \
    --pid $$

# Cleanup on exit
trap 'idlergear run complete "$SCRIPT_NAME" --exit-code $?' EXIT INT TERM

# Main work
echo "=== Starting $SCRIPT_NAME ==="
{{{command}}}
echo "=== $SCRIPT_NAME completed ==="
```

**Usage:**
```bash
# Generate a script
idlergear run create-script test-suite \
    --command "pytest tests/ -v --cov=src" \
    --output scripts/run_tests.sh

# Creates scripts/run_tests.sh with:
# - Auto-detect and activate venv
# - Register with daemon
# - Cleanup on exit
# - Log to .idlergear/logs/test-suite.log
```

### 3. Enhanced CLAUDE.md Guidance

Add section to CLAUDE.md:

```markdown
## Long-Running Process Policy

**NEVER run long-running processes (>30s) directly via Bash tool.**

Instead, use one of these patterns:

### Pattern 1: Generate script + tell user to run
```bash
# Generate script
idlergear run create-script training \
    --command "python train.py --epochs 100"

# Tell user:
"I've created scripts/run_training.sh. Run in a separate terminal:
  ./scripts/run_training.sh"
```

### Pattern 2: Use daemon directly
```bash
idlergear run start "pytest tests/" --name tests --auto-env
```

### What counts as long-running?
- Test suites, builds, training (>30s)
- Database migrations
- Web servers
- Large file processing

### What to run directly?
- Quick tests (<30s)
- Git commands
- File operations
```

### 4. Efficient Log Monitoring (inotify/FSEvents)

**Current problem:** Polling logs is inefficient

**Solution:** Event-based file watching

```python
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class LogWatcher(FileSystemEventHandler):
    def __init__(self):
        self.offsets = {}  # Track file read positions
        
    def on_modified(self, event):
        if event.src_path.endswith('.log'):
            self.read_new_lines(event.src_path)
    
    def read_new_lines(self, path):
        """Read only new lines since last read."""
        offset = self.offsets.get(path, 0)
        with open(path, 'r') as f:
            f.seek(offset)
            new_lines = f.readlines()
            self.offsets[path] = f.tell()
        
        # Notify interested sessions
        self.emit_to_subscribers(path, new_lines)

# In daemon startup:
observer = Observer()
observer.schedule(LogWatcher(), ".idlergear/logs", recursive=False)
observer.start()
```

### 5. MCP Tool Enhancement

Update `run_start` description:

```python
@mcp.tool()
def run_start(command: str, name: str = None, auto_env: bool = True):
    """
    Start a long-running process with IdlerGear daemon monitoring.
    
    **CRITICAL: Use this for any process >30 seconds**
    
    Features:
    - Auto-activates dev environment (venv, conda, nvm)
    - Captures logs to .idlergear/logs/
    - Monitors process status
    - Survives Claude Code restart
    
    Use for:
    - Test suites, builds, training
    - Database migrations
    - Any process >30 seconds
    
    Short processes (<30s): Use Bash tool directly
    
    Example:
        run_start("pytest tests/", name="test-suite")
        # Auto-detects venv and activates it
    """
```

### 6. UserPromptSubmit Hook - Auto-Detection

```bash
#!/bin/bash
# .claude/hooks/user-prompt-submit.sh

PROMPT=$(cat | jq -r '.prompt')

# Detect long-running process keywords
if echo "$PROMPT" | grep -qiE "(run tests|build|train|benchmark|migrate)"; then
    cat <<EOF
{
  "additionalContext": "⚠️ LONG-RUNNING PROCESS DETECTED

This appears to be a long-running task. Use:
  idlergear run create-script <name> --command '...'

Or:
  idlergear run start '...' --name <name> --auto-env

See: reference 'Shell Script Pattern for Long-Running Processes'"
}
EOF
fi
```

## Configuration

```toml
# .idlergear/config.toml
[run]
auto_activate_env = true  # Default: auto-detect and activate
log_dir = ".idlergear/logs"

[run.env]
# Environment detection order
detection_order = ["venv", "conda", "nvm", "rbenv"]

# Python
python_venv_paths = ["venv", ".venv", "env"]

# Node.js
node_version_file = ".nvmrc"

# Conda
conda_env_file = "environment.yml"

# Ruby
ruby_version_file = ".ruby-version"
```

## Implementation Plan

### Phase 1: Environment Auto-Detection
- [ ] Implement `detect_environment()` function
- [ ] Support Python venv detection
- [ ] Support Node.js nvm detection
- [ ] Support Conda environment detection
- [ ] Support Ruby rbenv detection
- [ ] Add `--auto-env` flag to `run start`
- [ ] Add config: `run.auto_activate_env`

### Phase 2: Script Templates
- [ ] Create `templates/run_script.sh` template
- [ ] Implement `idlergear run create-script` command
- [ ] Template variable substitution (name, command, env)
- [ ] Auto-detect environment for template
- [ ] Make script executable automatically

### Phase 3: Efficient Log Monitoring
- [ ] Add `watchdog` dependency (inotify/FSEvents wrapper)
- [ ] Implement `LogWatcher` class
- [ ] Track file offsets (read only new lines)
- [ ] Integrate with daemon startup
- [ ] Emit log updates to MCP subscribers

### Phase 4: Enhanced Status
- [ ] `idlergear run status <name>` shows last N log lines
- [ ] Add `--tail <n>` flag (default: 10)
- [ ] Add `--follow` flag for live streaming
- [ ] MCP tool returns structured status with logs

### Phase 5: CLAUDE.md + Hook Integration
- [ ] Add "Long-Running Process Policy" to CLAUDE.md template
- [ ] Implement UserPromptSubmit hook for detection
- [ ] Update MCP tool descriptions with guidance
- [ ] Add examples to AGENTS.md

## Use Cases

### Use Case 1: Run Tests
```bash
# User: "run the full test suite"

# Claude Code:
idlergear run create-script test-suite \
    --command "pytest tests/ -v --cov=src"

# Creates scripts/run_tests.sh

# Claude tells user:
"I've created scripts/run_tests.sh. Run in a separate terminal:
  ./scripts/run_tests.sh
  
Check status: idlergear run status test-suite
View logs: idlergear run logs test-suite --follow"
```

### Use Case 2: Training ML Model
```bash
# User: "train the model for 100 epochs"

# Claude Code creates scripts/run_training.sh:
#!/bin/bash
set -euo pipefail

# Auto-activate venv
source venv/bin/activate

# Register with daemon
idlergear run start \
    --name "training" \
    --command "python train.py --epochs 100" \
    --log ".idlergear/logs/training.log" \
    --pid $$

trap 'idlergear run complete "training" --exit-code $?' EXIT

python train.py --epochs 100
```

### Use Case 3: Background Build
```bash
# User: "build the project"

# Claude Code:
idlergear run start "npm run build" --name build --auto-env

# Daemon:
# - Detects .nvmrc
# - Runs: nvm use && npm run build
# - Logs to .idlergear/logs/build.log
# - User can check: idlergear run status build
```

## Technical Details

### Environment Detection Priority

1. **Python**: Check for venv, .venv, env directories
2. **Node.js**: Check for .nvmrc file
3. **Conda**: Check for environment.yml
4. **Ruby**: Check for .ruby-version

### Script Template Variables

| Variable | Description | Example |
|----------|-------------|---------|
| `{{name}}` | Script name | "test-suite" |
| `{{command}}` | Command to run | "pytest tests/" |
| `{{env_activate}}` | Environment activation | "source venv/bin/activate" |
| `{{log_path}}` | Log file path | ".idlergear/logs/test-suite.log" |

### Log Watching Performance

- **inotify (Linux)**: No polling, kernel events
- **FSEvents (macOS)**: No polling, kernel events
- **File offset tracking**: Only read new lines
- **Memory efficient**: Don't hold entire log in memory

## Benefits

1. ✅ **No manual environment setup** - Auto-detects and activates
2. ✅ **Standardized pattern** - Templates ensure consistency
3. ✅ **Efficient monitoring** - Event-based, not polling
4. ✅ **Session independence** - Processes survive Claude restarts
5. ✅ **Clear guidance** - Claude knows when to use separate terminal
6. ✅ **User-friendly** - Simple commands, clear output

## Related Issues

- #19 - Daemon-based prompt queue (uses run system)
- #112 - Watch mode (can trigger run scripts)
- #113 - Status command (includes run status)
- #66 - Unified daemon architecture (run monitoring)

## Acceptance Criteria

- [ ] `idlergear run start --auto-env` detects and activates venv
- [ ] `idlergear run create-script` generates working script
- [ ] Scripts auto-register with daemon
- [ ] Log monitoring uses inotify/FSEvents (no polling)
- [ ] `idlergear run status <name>` shows last 10 log lines
- [ ] `idlergear run logs <name> --follow` streams logs
- [ ] CLAUDE.md includes long-running process policy
- [ ] UserPromptSubmit hook detects long-running requests
- [ ] MCP tool descriptions updated with guidance
- [ ] Works with Python (venv), Node.js (nvm), Conda, Ruby (rbenv)
